#Makefile_WF1-6pe_template
#
#Makefile for BWASP workflow steps 1-6, from downloading SRA data to the Creport and methylation calls.
#Labeling of steps follows Figs. 1 & 2 in the manuscript.
#
#This is the paired-read version.  For single-read analysis, use Makefile_WF1-6se_template.
#Version: March 26, 2016.

#Typical usage:
#
#	cp Makefile_WF1-6pe_template Makefile_WF1-6pe_yours
#		(copy the template makefile, edit appropriately as per instructions below)
#	make -j 4 -f Makefile_WF1-6pe_yours
#       make -f Makefile_WF1-6_pe_yours cleanup
#       make -f Makefile_WF1-6_pe_yours finishup


########################################################################################################################
#Please be careful while editing the Makefile as it is 'tab-sensitive'.
#Typical customization should only involve apppropriate editing of the variables in the next section.
#
#The following variables specify the data sets and labels to be used.
#
#This template illustrates the settings for analysis of a Polistes canadensis data set to be downloaded
#from the NCBI Short Read Archive.  The GENOME variable must be set in accordance with the deposition
#of the genome sequence file in the genome directory read by the workflow.  Specifically, in the directory
#where you invoke "make", there should be a subdirectory "genome" which contains the file $(GENOME).fa
#(a FASTA-formatted file containing the genome sequences).
#
#The SAMPLE and SOURCE variables must be set to the SRA data set label and the appropriate download
#directory.  SYNONYM is a label used by BWASP do uniquely label output files.
#
#Note: Download from NCBI SRA is of course not required but merely a convenience for ease of access and
#      reproducibility.  Alternatively, you can simply deposit files $(SAMPLE)_1.fastq and $(SAMPLE)_2.fastq
#      in the directory where you invoke "make".  For example, assume you have your own read files
#      mydata_1.fastq and mydata_2.fastq.  Then you could use a copy of this makefile by setting
#      SAMPLE = mydata and invoking "touch mydata.sra; touch mydata_*.fastq" before running make
#      (alternatively, you could delete section 1.1 below before running make).
#
GENOME  = Pcan.gdna
SAMPLE  = SRR1519132
SYNONYM = Pcan-21Q

SOURCE  = "ftp://ftp-trace.ncbi.nlm.nih.gov/sra/sra-instant/reads/ByRun/sra/SRR/SRR151/$(SAMPLE)"

#The following variables set the directories where BWASP requrired binaries reside.  In this
#template, the BWASP package was cloned in a user's ~/gitwd directory, and required other
#software was installed under /usr/local/src/BWASP.
#
BINDIR  = ~/gitwd/BWASP/bin
SRCDIR  = /usr/local/src/BWASP

BISMARK     = $(SRCDIR)/BISMARK/bismark_v0.15.0
BOWTIE2     = $(SRCDIR)/BOWTIE2/bowtie2-2.2.7
FASTQC      = $(SRCDIR)/FASTQC/FastQC
SAMTOOLS    = $(SRCDIR)/SAMTOOLS/samtools
SRATOOLKIT  = $(SRCDIR)/SRATOOLKIT/sratoolkit.2.5.7-centos_linux64/bin
TRIM_GALORE = $(SRCDIR)/TRIM_GALORE/trim_galore_zip

#The following variables set options for programs called in the BWASP workflow.
#Please read the instructions of the respective programs to make choices that fit your
#data analysis needs.
#
BOWTIE2_OPTIONS       = -p 4 --score_min L,0,-0.6
BISMARK_OPTIONS       = --multicore 14 --path_to_bowtie $(BOWTIE2) --bowtie2 $(BOWTIE2_OPTIONS) --samtools_path $(SAMTOOLS)/samtools
FASTQC_OPTIONS        = --threads 2  --extract
SAMTOOLS_SORT_OPTIONS = -m 25G -@ 4
TRIM_GALORE_OPTIONS   = 
SORT_BUFFER_SIZE      = 20G
BME_OPTIONS           = --multicore 10  --buffer_size $(SORT_BUFFER_SIZE)
#
### ! Note: The --phred33/64 option to trim_galore is set below according to the output of FastQC
###
########################################################################################################################
### ! Typically there would be no need for further editing below this line ! ###
run_gprep = no
ifeq ("$(wildcard ./genome/Bisulfite_Genome/CT_conversion/genome_mfa.CT_conversion.fa)","")
	run_gprep = yes
endif
ifeq ("$(wildcard ./genome/Bisulfite_Genome/GA_conversion/genome_mfa.GA_conversion.fa)","")
	run_gprep = yes
endif


all:	genome fastqc1 fastqc2 $(SYNONYM).sam $(SYNONYM).M-bias.eval $(SYNONYM).Creport \
	CXreports CpGmcalls CHGmcalls CHHmcalls $(SYNONYM).mstats \
	sample_stats
sample_stats:	rawread_nb rawread_lgth rawsample_size trmread_nb trmread_lgth trmsample_size genome_coverage
.PHONY:	genome Bisulfite_Genome \
	sample_stats rawread_nb rawread_lgth rawsample_size trmread_nb trmread_lgth trmsample_size genome_coverage


###1.1 bismark genome preparation.
###    (requires the genome of interest, $(GENOME).fa, to have been placed into the folder ./genome)
#
genome:	./genome/$(GENOME).fa Bisulfite_Genome

./genome/$(GENOME).fa:	
ifeq ("$(wildcard ./genome/$(GENOME).fa)","")
	$(error No genome file ./genome/$(GENOME).fa found. Please provide.)
endif

Bisulfite_Genome:
ifeq ("$(run_gprep)","yes")
	$(BISMARK)/bismark_genome_preparation --path_to_bowtie $(BOWTIE2) --bowtie2 ./genome
endif


###1.2 Obtain the SRA reads from NCBI:
#
$(SAMPLE).sra:	
	wget $(SOURCE)/$(SAMPLE).sra

%_1.fastq %_2.fastq:	%.sra
	$(SRATOOLKIT)/fastq-dump --split-files $*.sra
ifeq ("$(wildcard ./FastQC)","")
	mkdir FastQC
endif


###1.3 Run FastQC to check the quality of the reads:
#
fastqc1:	FastQC/$(SAMPLE)_1_fastqc/fastqc_data.txt FastQC/$(SAMPLE)_2_fastqc/fastqc_data.txt

FastQC/$(SAMPLE)_1_fastqc/fastqc_data.txt:	$(SAMPLE)_1.fastq
	$(FASTQC)/fastqc  $(FASTQC_OPTIONS)  --outdir=FastQC  $(SAMPLE)_1.fastq

FastQC/$(SAMPLE)_2_fastqc/fastqc_data.txt:	$(SAMPLE)_2.fastq
	$(FASTQC)/fastqc  $(FASTQC_OPTIONS)  --outdir=FastQC  $(SAMPLE)_2.fastq


###1.4 Trim the reads to remove low quality bases and adapater sequences:
#
%_1_val_1.fq %_2_val_2.fq:	%_1.fastq %_2.fastq FastQC/$(SAMPLE)_1_fastqc/fastqc_data.txt
	$(eval ENCODING = $(shell awk 'NR==6' FastQC/$(SAMPLE)_1_fastqc/fastqc_data.txt | awk -F" " '{printf("%s",$$5)}'))
	if [ $(ENCODING) = "1.9" ]; then \
		$(TRIM_GALORE)/trim_galore  $(TRIM_GALORE_OPTIONS) --phred33  --paired $*_1.fastq $*_2.fastq; \
	else \
		$(TRIM_GALORE)/trim_galore  $(TRIM_GALORE_OPTIONS) --phred64  --paired $*_1.fastq $*_2.fastq; \
	fi


###1.5 Run FastQC again to check the quality of the trimmed reads:
#
fastqc2:	FastQC/$(SAMPLE)_1_val_1_fastqc/fastqc_data.txt FastQC/$(SAMPLE)_2_val_2_fastqc/fastqc_data.txt

FastQC/$(SAMPLE)_1_val_1_fastqc/fastqc_data.txt:	$(SAMPLE)_1_val_1.fq
	$(FASTQC)/fastqc  $(FASTQC_OPTIONS)  --outdir=FastQC  $(SAMPLE)_1_val_1.fq

FastQC/$(SAMPLE)_2_val_2_fastqc/fastqc_data.txt:	$(SAMPLE)_2_val_2.fq
	$(FASTQC)/fastqc  $(FASTQC_OPTIONS)  --outdir=FastQC  $(SAMPLE)_2_val_2.fq


###2.1-2 Map the reads to the genome (using bowtie2 via bismark):
#
$(SAMPLE)_1_val_1.fq_bismark_bt2_pe.bam:	$(SAMPLE)_1_val_1.fq $(SAMPLE)_2_val_2.fq
	$(BISMARK)/bismark  $(BISMARK_OPTIONS)  ./genome -1 $(SAMPLE)_1_val_1.fq -2 $(SAMPLE)_2_val_2.fq

$(SAMPLE)_1_val_1.fq_bismark_bt2_pe.sam:	$(SAMPLE)_1_val_1.fq_bismark_bt2_pe.bam
	$(SAMTOOLS)/samtools view $(SAMPLE)_1_val_1.fq_bismark_bt2_pe.bam > $(SAMPLE)_1_val_1.fq_bismark_bt2_pe.sam


###2.3 Remove potential PCR artefacts using the bismark deduplication script:
#
$(SYNONYM)-deduplicated.sam:	$(SAMPLE)_1_val_1.fq_bismark_bt2_pe.sam
	$(BISMARK)/deduplicate_bismark -p $(SAMPLE)_1_val_1.fq_bismark_bt2_pe.sam
	mv $(SAMPLE)_1_val_1.fq_bismark_bt2_pe.deduplicated.sam $(SYNONYM)-deduplicated.sam


###2.4 Filter reads to remove likely non-BS-treated contaminants:
#
$(SYNONYM).sam:	$(SYNONYM)-deduplicated.sam $(SAMPLE)-header.sam
	$(BINDIR)/xfilterMsam $(BINDIR) p $(SYNONYM)-deduplicated
	cat $(SAMPLE)-header.sam Accepted-Reads-$(SYNONYM)-deduplicated.sam > $(SYNONYM).sam

$(SAMPLE)-header.sam:	$(SAMPLE)_1_val_1.fq_bismark_bt2_pe.bam
	$(SAMTOOLS)/samtools view -H $(SAMPLE)_1_val_1.fq_bismark_bt2_pe.bam > $(SAMPLE)-header.sam


###3.1-2 Determine potential methylation-biased positions in the reads:
#
$(SYNONYM).M-bias.txt:	$(SYNONYM).sam
	$(BISMARK)/bismark_methylation_extractor $(BME_OPTIONS) --mbias_only -p $(SYNONYM).sam
	mv $(SYNONYM)_splitting_report.txt $(SYNONYM)_mbias_only_splitting_report.txt

$(SYNONYM).M-bias.eval:	$(SYNONYM).M-bias.txt
	python $(BINDIR)/eval_prmbias.py $(SYNONYM).M-bias.txt > $(SYNONYM).M-bias.eval


###3.3-4 Generate the Creport file:
#
$(SYNONYM).bismark.cov.gz:	$(SYNONYM).M-bias.eval $(SYNONYM).sam
	$(eval R1FP = $(shell egrep "^--ignore" $(SYNONYM).M-bias.eval | awk -F" " '{print $$2}'))
	$(eval R1TP = $(shell egrep "^--ignore" $(SYNONYM).M-bias.eval | awk -F" " '{print $$4}'))
	$(eval R2FP = $(shell egrep "^--ignore" $(SYNONYM).M-bias.eval | awk -F" " '{print $$6}'))
	$(eval R2TP = $(shell egrep "^--ignore" $(SYNONYM).M-bias.eval | awk -F" " '{print $$8}'))
	$(BISMARK)/bismark_methylation_extractor $(BME_OPTIONS) --mbias_off -p --ignore $(R1FP) --ignore_3prime $(R1TP) --ignore_r2 $(R2FP) --ignore_3prime_r2 $(R2TP)  --bedGraph --CX --scaffolds $(SYNONYM).sam

$(SYNONYM).cov:	$(SYNONYM).bismark.cov.gz
	zcat $(SYNONYM).bismark.cov.gz | sort -V -S $(SORT_BUFFER_SIZE) > $(SYNONYM).cov

creport:	./genome/$(GENOME).fa $(SYNONYM).cov
	$(BISMARK)/coverage2cytosine -o creport --genome_folder ./genome --CX  $(SYNONYM).cov

$(SYNONYM).Creport:	creport
	sort -V -S $(SORT_BUFFER_SIZE) creport > $(SYNONYM).Creport


###5.1-2 Generate the CXreport files:
#
CXreports:	$(SYNONYM).CpGreport $(SYNONYM).CHGreport $(SYNONYM).CHHreport $(SYNONYM).HSMthresholds

%.CpGreport %.CHGreport %.CHHreport %.HSMthresholds:	%.Creport
	python $(BINDIR)/Creport2CXreport.py $*.Creport $*.CpGreport $*.CHGreport $*.CHHreport > $*.HSMthresholds


###5.3 Highly supported methylation sites calculation using the CXreport2hsm.py script.
#
CpGmcalls:	$(SYNONYM).CpGscd.mcalls $(SYNONYM).CpGhsm.mcalls $(SYNONYM).CpGnsm.mcalls

%.CpGscd.mcalls %.CpGhsm.mcalls %.CpGnsm.mcalls:	%.HSMthresholds %.CpGreport
	$(eval CpGnval = $(shell egrep "Thus.*CpG" $*.HSMthresholds | awk '{print $$NF}'))
	python $(BINDIR)/CXreport2hsm.py $*.CpGreport $(CpGnval) $*.CpGscd.mcalls $*.CpGhsm.mcalls $*.CpGnsm.mcalls

CHGmcalls:	$(SYNONYM).CHGscd.mcalls $(SYNONYM).CHGhsm.mcalls $(SYNONYM).CHGnsm.mcalls

%.CHGscd.mcalls %.CHGhsm.mcalls %.CHGnsm.mcalls:	%.HSMthresholds %.CHGreport
	$(eval CHGnval = $(shell egrep "Thus.*CHG" $*.HSMthresholds | awk '{print $$NF}'))
	python $(BINDIR)/CXreport2hsm.py $*.CHGreport $(CHGnval) $*.CHGscd.mcalls $*.CHGhsm.mcalls $*.CHGnsm.mcalls

CHHmcalls:	$(SYNONYM).CHHscd.mcalls $(SYNONYM).CHHhsm.mcalls $(SYNONYM).CHHnsm.mcalls

%.CHHscd.mcalls %.CHHhsm.mcalls %.CHHnsm.mcalls:	%.HSMthresholds %.CHHreport
	$(eval CHHnval = $(shell egrep "Thus.*CHH" $*.HSMthresholds | awk '{print $$NF}'))
	python $(BINDIR)/CXreport2hsm.py $*.CHHreport $(CHHnval) $*.CHHscd.mcalls $*.CHHhsm.mcalls $*.CHHnsm.mcalls


###6.1. Print methylation statistics.
#
$(SYNONYM).mstats:	$(SYNONYM).Creport CpGmcalls CHGmcalls CHHmcalls
	$(BINDIR)/mstats.sh $(SYNONYM) > $(SYNONYM).mstats



#Genome statistics:
#
$(GENOME).stats:	./genome/$(GENOME).fa
	$(BINDIR)/asmbleval.pl < ./genome/$(GENOME).fa > $(GENOME).stats


#Number of raw reads:
# (to obtain the number of reads, we add the number of lines in both read files divided by 4)
#
rawread_nb:	$(SAMPLE)_1.fastq $(SAMPLE)_2.fastq		
	$(eval RAWREAD_NB1 = $(shell wc -l $(SAMPLE)_1.fastq|cut -d' ' -f1))
	$(eval RAWREAD_NB2 = $(shell wc -l $(SAMPLE)_2.fastq|cut -d' ' -f1 ))
	$(eval RAWREAD_NB  = $(shell awk "BEGIN {print $(RAWREAD_NB1)/4+$(RAWREAD_NB2)/4}"))
	@echo "Number of raw reads: $(RAWREAD_NB) (sum of left and right reads)" > $(SAMPLE).stats

#Raw read length:
#
rawread_lgth:	FastQC/$(SAMPLE)_1_fastqc/fastqc_data.txt FastQC/$(SAMPLE)_2_fastqc/fastqc_data.txt	
	$(eval RAWREAD_LGTH1 = $(shell awk 'NR==9' FastQC/$(SAMPLE)_1_fastqc/fastqc_data.txt | awk -F" " '{print $$3}'))
	$(eval RAWREAD_LGTH2 = $(shell awk 'NR==9' FastQC/$(SAMPLE)_2_fastqc/fastqc_data.txt | awk -F" " '{print $$3}'))
	@echo "Raw read length (per FastQC report): $(RAWREAD_LGTH1) (left reads), $(RAWREAD_LGTH2) (right reads)" >> $(SAMPLE).stats

#Raw sample size:
#
rawsample_size:	rawread_nb
	$(eval RAWREAD_SZE1 = $(shell awk 'BEGIN{sum=0;}{if(NR%4==2){sum+=length($0);}}END{print sum;}' $(SAMPLE)_1.fastq))
	$(eval RAWREAD_SZE2 = $(shell awk 'BEGIN{sum=0;}{if(NR%4==2){sum+=length($0);}}END{print sum;}' $(SAMPLE)_2.fastq))
	$(eval RAWSAMPLE_SZE =$(shell awk "BEGIN {print $(RAWREAD_SZE1) + $(RAWREAD_SZE2)}")) 
	@echo "Raw read sample size: $(RAWSAMPLE_SZE) bp" >> $(SAMPLE).stats


#Number of trimmed reads:
#
trmread_nb:	$(SAMPLE)_1_val_1.fq $(SAMPLE)_2_val_2.fq		
	$(eval TRMREAD_NB1 = $(shell wc -l $(SAMPLE)_1_val_1.fq|cut -d' ' -f1))
	$(eval TRMREAD_NB2 = $(shell wc -l $(SAMPLE)_2_val_2.fq|cut -d' ' -f1 ))
	$(eval TRMREAD_NB  = $(shell awk "BEGIN {print $(TRMREAD_NB1)/4+$(TRMREAD_NB2)/4}"))
	@echo "Number of trimmed reads: $(TRMREAD_NB) (sum of left and right reads)" >> $(SAMPLE).stats

#Trimmed read length:
#
trmread_lgth:	FastQC/$(SAMPLE)_1_val_1_fastqc/fastqc_data.txt FastQC/$(SAMPLE)_2_val_2_fastqc/fastqc_data.txt	
	$(eval TRMREAD_LGTH1 = $(shell awk 'NR==9' FastQC/$(SAMPLE)_1_val_1_fastqc/fastqc_data.txt | awk -F" " '{print $$3}'))
	$(eval TRMREAD_LGTH2 = $(shell awk 'NR==9' FastQC/$(SAMPLE)_2_val_2_fastqc/fastqc_data.txt | awk -F" " '{print $$3}'))
	@echo "Trimmed read length range (per FastQC report): $(TRMREAD_LGTH1) (left reads), $(TRMREAD_LGTH2) (right reads)" >> $(SAMPLE).stats
	$(eval TRMREAD_ML1 = $(shell cat $(SAMPLE)_1_val_1.fq | awk '{if(NR%4==2) print length($1)}' > /tmp/$(SAMPLE)_readlength1.txt; sort -n /tmp/$(SAMPLE)_readlength1.txt| awk ' { a[i++]=$$1; } END { print a[int(i/2)]; }'))
	$(eval TRMREAD_ML2 = $(shell cat $(SAMPLE)_2_val_2.fq | awk '{if(NR%4==2) print length($1)}' > /tmp/$(SAMPLE)_readlength2.txt; sort -n /tmp/$(SAMPLE)_readlength2.txt| awk ' { a[i++]=$$1; } END { print a[int(i/2)]; }'))
	@echo "Median length of trimmed reads: $(TRMREAD_ML1) (left reads), $(TRMREAD_ML2) (right reads)" >> $(SAMPLE).stats

#Trimmed sample size:
#
trmsample_size:	trmread_nb
	$(eval TRMREAD_SZE1 = $(shell awk 'BEGIN{sum=0;}{if(NR%4==2){sum+=length($0);}}END{print sum;}' $(SAMPLE)_1_val_1.fq))
	$(eval TRMREAD_SZE2 = $(shell awk 'BEGIN{sum=0;}{if(NR%4==2){sum+=length($0);}}END{print sum;}' $(SAMPLE)_2_val_2.fq))
	$(eval TRMSAMPLE_SZE =$(shell awk "BEGIN {print $(TRMREAD_SZE1) + $(TRMREAD_SZE2)}")) 
	@echo "Trimmed sample size: $(TRMSAMPLE_SZE) bp" >> $(SAMPLE).stats


#Genome coverage:
# (using samtools to first convert the SAM file into a sorted BAM file, then "samtools depth" to obtain the total aligned base
#  count, and finally dividing that value by the genome size to obtain the coverage)
genome_coverage:	$(SYNONYM).bam $(GENOME).stats
	$(eval TOTAL_ALGNDBASE_CNT = $(shell $(SAMTOOLS)/samtools depth $(SYNONYM).bam | awk '{sum+=$$3}END{print sum}'))
	$(eval genome_size = $(shell awk 'NR==1{print $$4}' $(GENOME).stats))
	$(eval COVERAGE = $(shell awk "BEGIN {printf \"%.2f\", $(TOTAL_ALGNDBASE_CNT)/$(genome_size) }"))
	@echo "Genome coverage: $(COVERAGE) (= $(TOTAL_ALGNDBASE_CNT) / $(genome_size))" >> $(SAMPLE).stats

$(SYNONYM).bam:	$(SYNONYM).sam
	$(SAMTOOLS)/samtools view -bS $(SYNONYM).sam | $(SAMTOOLS)/samtools sort $(SAMTOOLS_SORT_OPTIONS) -o $(SYNONYM).bam -



###Clean up the output directory:
#
cleanup:
	-\mkdir _SCRATCH
	-\mv $(SAMPLE).sra _SCRATCH
	-\mv $(SAMPLE)_*.fastq _SCRATCH
	-\mv $(SAMPLE)_*.fq _SCRATCH
	-\mv $(SAMPLE)_1_val_1.fq_bismark_bt2_pe.sam _SCRATCH
	-\mv $(SYNONYM)-deduplicated.sam _SCRATCH
	-\mv Accepted-Reads-$(SYNONYM)-deduplicated.sam _SCRATCH
	-\mv $(SYNONYM).bedGraph.gz _SCRATCH
	-\mv $(SYNONYM).bismark.cov.gz _SCRATCH
	-\mv creport _SCRATCH
	 
	-\mkdir STORE-$(SAMPLE)
	-\mv $(SAMPLE)_1_val_1.fq_bismark_bt2_pe.bam STORE-$(SAMPLE)
	-\mv $(SYNONYM).sam STORE-$(SAMPLE)/
	-\mv CHH*txt CHG*txt STORE-$(SAMPLE)
	-\mv $(SYNONYM).cov STORE-$(SAMPLE)
	-\mv $(SYNONYM)*report STORE-$(SAMPLE)
	
###Finish up after cleanup:
#
finishup:
	-\rm -rf _SCRATCH
	zip -r STORE-$(SAMPLE) STORE-$(SAMPLE)
	-\rm -rf STORE-$(SAMPLE)
